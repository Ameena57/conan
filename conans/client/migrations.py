import os

from conans.cli.output import ConanOutput
from conans.client.cache.cache import ClientCache
from conans.migrations import Migrator
from conans.util.files import load, save

CONAN_GENERATED_COMMENT = "This file was generated by Conan"


def update_file(file_path, new_content):
    """
    Update any file path given with the new content.
    Notice that the file is only updated whether it contains the ``CONAN_GENERATED_COMMENT``.

    :param file_path: ``str`` path to the file.
    :param new_content: ``str`` content to be saved.
    """
    out = ConanOutput()
    file_name = os.path.basename(file_path)

    if not os.path.exists(file_path):
        out.warning(f"Migration: This conan installation does not have {file_name} yet")
        out.warning(f"Nothing to migrate here, {file_name} will be generated automatically")
        return

    content = load(file_path)
    if CONAN_GENERATED_COMMENT not in content.split("\n", 1)[0]:
        out.warning(f"Migration: {file_path} does not contain the Conan"
                    f" comment: '{CONAN_GENERATED_COMMENT}'. Ignoring it")
    elif content != new_content:
        save(file_path, new_content)
        out.success(f"Migration: Successfully updated {file_name}")


class ClientMigrator(Migrator):

    def __init__(self, cache_folder, current_version):
        self.cache_folder = cache_folder
        super(ClientMigrator, self).__init__(cache_folder, current_version)

    def _apply_migrations(self, old_version):
        # Migrate the settings if they were the default for that version
        cache = ClientCache(self.cache_folder)
        # Time for migrations!
        # Update settings.yml
        from conans.client.conf import migrate_settings_file
        migrate_settings_file(cache, update_file)
        # Update compatibility.py, app_compat.py, and cppstd_compat.py.
        from conans.client.graph.compatibility import migrate_compatibility_files
        migrate_compatibility_files(cache, update_file)

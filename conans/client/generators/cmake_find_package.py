from jinja2 import Template
import textwrap

from conans.client.generators.cmake import DepsCppCmake
from conans.client.generators.cmake_find_package_common import (target_template,
                                                                CMakeFindPackageCommonMacros,
                                                                find_transitive_dependencies,
                                                                target_template_info)
from conans.client.generators.cmake_multi import extend
from conans.errors import ConanException
from conans.model import Generator


class CMakeFindPackageGenerator(Generator):
    find_template = textwrap.dedent("""
        {macros_and_functions}

        include(FindPackageHandleStandardArgs)

        conan_message(STATUS "Conan: Using autogenerated Find{name}.cmake")
        # Global approach
        set({name}_FOUND 1)
        set({name}_VERSION "{version}")

        find_package_handle_standard_args({name} REQUIRED_VARS
                                          {name}_VERSION VERSION_VAR {name}_VERSION)
        mark_as_advanced({name}_FOUND {name}_VERSION)

        {find_libraries_block}
        if(NOT ${{CMAKE_VERSION}} VERSION_LESS "3.0")
            # Target approach
            if(NOT TARGET {name}::{name})
                add_library({name}::{name} INTERFACE IMPORTED)
                if({name}_INCLUDE_DIRS)
                    set_target_properties({name}::{name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES
                                          "${{{name}_INCLUDE_DIRS}}")
                endif()
                set_property(TARGET {name}::{name} PROPERTY INTERFACE_LINK_LIBRARIES
                             "${{{name}_LIBRARIES_TARGETS}};${{{name}_LINKER_FLAGS_LIST}}")
                set_property(TARGET {name}::{name} PROPERTY INTERFACE_COMPILE_DEFINITIONS
                             ${{{name}_COMPILE_DEFINITIONS}})
                set_property(TARGET {name}::{name} PROPERTY INTERFACE_COMPILE_OPTIONS
                             "${{{name}_COMPILE_OPTIONS_LIST}}")
                {find_dependencies_block}
            endif()
        endif()
        """)

    find_components_tpl = Template(textwrap.dedent("""
        ########## MACROS ###########################################################################
        {% raw %}
        function(conan_message MESSAGE_OUTPUT)
            if(NOT CONAN_CMAKE_SILENT_OUTPUT)
                message(${ARGV${0}})
            endif()
        endfunction()

        macro(conan_find_apple_frameworks FRAMEWORKS_FOUND FRAMEWORKS FRAMEWORKS_DIRS)
            if(APPLE)
                foreach(_FRAMEWORK ${FRAMEWORKS})
                    # https://cmake.org/pipermail/cmake-developers/2017-August/030199.html
                    find_library(CONAN_FRAMEWORK_${_FRAMEWORK}_FOUND NAME ${_FRAMEWORK} PATHS ${FRAMEWORKS_DIRS})
                    if(CONAN_FRAMEWORK_${_FRAMEWORK}_FOUND)
                        list(APPEND ${FRAMEWORKS_FOUND} ${CONAN_FRAMEWORK_${_FRAMEWORK}_FOUND})
                    else()
                        message(FATAL_ERROR "Framework library ${_FRAMEWORK} not found in paths: ${FRAMEWORKS_DIRS}")
                    endif()
                endforeach()
            endif()
        endmacro()

        function(conan_package_library_targets libraries package_libdir deps out_libraries out_libraries_target build_type package_name)
            unset(_CONAN_ACTUAL_TARGETS CACHE)
            unset(_CONAN_FOUND_SYSTEM_LIBS CACHE)
            foreach(_LIBRARY_NAME ${libraries})
                find_library(CONAN_FOUND_LIBRARY NAME ${_LIBRARY_NAME} PATHS ${package_libdir}
                             NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
                if(CONAN_FOUND_LIBRARY)
                    conan_message(STATUS "Library ${_LIBRARY_NAME} found ${CONAN_FOUND_LIBRARY}")
                    list(APPEND _out_libraries ${CONAN_FOUND_LIBRARY})
                    if(NOT ${CMAKE_VERSION} VERSION_LESS "3.0")
                        # Create a micro-target for each lib/a found
                        set(_LIB_NAME CONAN_LIB::${package_name}_${_LIBRARY_NAME}${build_type})
                        if(NOT TARGET ${_LIB_NAME})
                            # Create a micro-target for each lib/a found
                            add_library(${_LIB_NAME} UNKNOWN IMPORTED)
                            set_target_properties(${_LIB_NAME} PROPERTIES IMPORTED_LOCATION ${CONAN_FOUND_LIBRARY})
                            set(_CONAN_ACTUAL_TARGETS ${_CONAN_ACTUAL_TARGETS} ${_LIB_NAME})
                        else()
                            conan_message(STATUS "Skipping already existing target: ${_LIB_NAME}")
                        endif()
                        list(APPEND _out_libraries_target ${_LIB_NAME})
                    endif()
                    conan_message(STATUS "Found: ${CONAN_FOUND_LIBRARY}")
                else()
                    conan_message(STATUS "Library ${_LIBRARY_NAME} not found in package, might be system one")
                    list(APPEND _out_libraries_target ${_LIBRARY_NAME})
                    list(APPEND _out_libraries ${_LIBRARY_NAME})
                    set(_CONAN_FOUND_SYSTEM_LIBS "${_CONAN_FOUND_SYSTEM_LIBS};${_LIBRARY_NAME}")
                endif()
                unset(CONAN_FOUND_LIBRARY CACHE)
            endforeach()

            if(NOT ${CMAKE_VERSION} VERSION_LESS "3.0")
                # Add all dependencies to all targets
                string(REPLACE " " ";" deps_list "${deps}")
                foreach(_CONAN_ACTUAL_TARGET ${_CONAN_ACTUAL_TARGETS})
                    set_property(TARGET ${_CONAN_ACTUAL_TARGET} PROPERTY INTERFACE_LINK_LIBRARIES "${_CONAN_FOUND_SYSTEM_LIBS};${deps_list}")
                endforeach()
            endif()

            set(${out_libraries} ${_out_libraries} PARENT_SCOPE)
            set(${out_libraries_target} ${_out_libraries_target} PARENT_SCOPE)
        endfunction()
        {% endraw %}
        #############################################################################################


        ########### FOUND ###########################################################################

        include(FindPackageHandleStandardArgs)

        conan_message(STATUS "Conan: Using autogenerated Find{{ pkg_name }}.cmake")
        # Global approach
        set({{ pkg_name }}_FOUND 1)
        set({{ pkg_name }}_VERSION "{{ pkg_version }}")

        find_package_handle_standard_args({{ pkg_name }} REQUIRED_VARS
                                          {{ pkg_name }}_VERSION VERSION_VAR {{ pkg_name }}_VERSION)
        mark_as_advanced({{ pkg_name }}_FOUND {{ pkg_name }}_VERSION)

        #############################################################################################


        ########### COMPONENTS ######################################################################

        {%- for comp_name, comp in components %}

        ########### COMPONENT {{ comp_name }} #######################################################
        set({{ comp_name }}_INCLUDE_DIRS {{ comp.include_paths }})
        set({{ comp_name }}_INCLUDE_DIR {{ comp.include_path }})
        set({{ comp_name }}_INCLUDES {{ comp.include_paths }})
        set({{ comp_name }}_RES_DIRS {{ comp.res_paths }})
        set({{ comp_name }}_DEFINITIONS {{ comp.defines }})
        set({{ comp_name }}_COMPILE_DEFINITIONS {{ comp.compile_definitions }})
        set({{ comp_name }}_COMPILE_OPTIONS_LIST "{{ comp.cxxflags_list }}" "{{ comp.cflags_list }}")
        set({{ comp_name }}_LIBS {{ comp.libs }})
        set({{ comp_name }}_SYSTEM_LIBS {{ comp.system_libs }})
        set({{ comp_name }}_FRAMEWORK_DIRS {{ comp.framework_paths }})
        set({{ comp_name }}_FRAMEWORKS {{ comp.frameworks }})
        set({{ comp_name }}_BUILD_MODULES_PATHS {{ comp.build_modules_paths }})
        set({{ comp_name }}_DEPENDENCIES {{ comp.public_deps }})
        #############################################################################################

        {%- endfor %}

        #############################################################################################


        ########## FIND PACKAGE DEPENDENCY ##########################################################

        include(CMakeFindDependencyMacro)

        {%- for public_dep in pkg_public_deps %}
        if(NOT {{ public_dep }}_FOUND)
            find_dependency({{ public_dep }} REQUIRED)
        else()
            message(STATUS "Dependency {{ public_dep }} already found")
        endif()
        {%- endfor %}

        #############################################################################################


        ########## TARGETS ##########################################################################

        {%- for comp_name, comp in components %}
        if(NOT ${CMAKE_VERSION} VERSION_LESS "3.0")
            # Target approach
            if(NOT TARGET {{ pkg_name }}::{{ comp_name }})
                add_library({{ pkg_name }}::{{ comp_name }} INTERFACE IMPORTED)
                set_target_properties({{ pkg_name }}::{{ comp_name }} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES
                                      "${% raw %}{{% endraw %}{{ comp_name }}_INCLUDE_DIRS{% raw %}}{% endraw %}")
                set_property(TARGET {{ pkg_name }}::{{ comp_name }} PROPERTY INTERFACE_LINK_DIRECTORIES
                             "${% raw %}{{% endraw %}{{ comp_name }}_LIB_DIRS{% raw %}}{% endraw %}")
                set_property(TARGET {{ pkg_name }}::{{ comp_name }} PROPERTY INTERFACE_LINK_LIBRARIES
                             "${% raw %}{{% endraw %}{{ comp_name }}_LIBS{% raw %}}{% endraw %};${% raw %}{{% endraw %}{{ comp_name }}_LINKER_FLAGS_LIST{% raw %}}{% endraw %}")
                set_property(TARGET {{ pkg_name }}::{{ comp_name }} PROPERTY INTERFACE_COMPILE_DEFINITIONS
                             ${% raw %}{{% endraw %}{{ comp_name }}_COMPILE_DEFINITIONS{% raw %}}{% endraw %})
                set_property(TARGET {{ pkg_name }}::{{ comp_name }} PROPERTY INTERFACE_COMPILE_OPTIONS
                             "${% raw %}{{% endraw %}{{ comp_name }}_COMPILE_OPTIONS_LIST{% raw %}}{% endraw %}")
            endif()
        endif()
        {%- endfor %}

        if(NOT ${CMAKE_VERSION} VERSION_LESS "3.0")
            if(NOT TARGET {{ pkg_name }}::{{ pkg_name }})
                add_library({{ pkg_name }}::{{ pkg_name }} INTERFACE IMPORTED)
                if({{ pkg_name }}_INCLUDE_DIRS)
                    set_target_properties({{ pkg_name }}::{{ pkg_name }} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES
                                          "${% raw %}{{% endraw %}{{ pkg_name }}_INCLUDE_DIRS{% raw %}}{% endraw %}")
                endif()
                set_property(TARGET {{ pkg_name }}::{{ pkg_name }} PROPERTY INTERFACE_LINK_LIBRARIES
                             "${% raw %}{{% endraw %}{{ pkg_name }}_LIBRARIES_TARGETS{% raw %}}{% endraw %};${% raw %}{{% endraw %}{{ pkg_name }}_LINKER_FLAGS_LIST{% raw %}}{% endraw %}")
                set_property(TARGET {{ pkg_name }}::{{ pkg_name }} PROPERTY INTERFACE_COMPILE_DEFINITIONS
                             ${% raw %}{{% endraw %}{{ pkg_name }}_COMPILE_DEFINITIONS{% raw %}}{% endraw %})
                set_property(TARGET {{ pkg_name }}::{{ pkg_name }} PROPERTY INTERFACE_COMPILE_OPTIONS
                             "${% raw %}{{% endraw %}{{ pkg_name }}_COMPILE_OPTIONS_LIST{% raw %}}{% endraw %}")
            endif()
        endif()
        #############################################################################################
    """))

    @property
    def filename(self):
        return None

    @property
    def content(self):
        ret = {}
        for dep_name, cpp_info in self.deps_build_info.dependencies:
            dep_findname = cpp_info.get_name("cmake_find_package")
            ret["Find%s.cmake" % dep_findname] = self._find_for_dep(dep_name, cpp_info)
        return ret

    def _get_components(self, pkg_name, pkg_findname, cpp_info):
        find_package_components = []
        for comp_name, comp in cpp_info._get_sorted_components().items():
            comp_findname = cpp_info.components[comp_name].get_name("cmake_find_package")
            deps_cpp_cmake = DepsCppCmake(comp)
            deps_cpp_cmake.public_deps = self._get_component_requires(pkg_name, pkg_findname, comp)
            find_package_components.append((comp_findname, deps_cpp_cmake))
        return find_package_components

    def _get_component_requires(self, dep_name, dep_findname, comp):
        comp_requires_findnames = []
        for require in comp.requires:
            if "::" in require:
                comp_require_dep_name = require[:require.find("::")]
                if comp_require_dep_name not in self.deps_build_info.deps:
                    raise ConanException("Component '%s' not found: '%s' is not a package "
                                         "requirement" % (require, comp_require_dep_name))
                comp_require_dep_findname = self.deps_build_info[comp_require_dep_name].get_name(
                    "cmake_find_package")
                comp_require_comp_name = require[require.find("::") + 2:]
                if comp_require_comp_name in self.deps_build_info.deps:
                    comp_require_comp_findname = comp_require_dep_findname
                elif comp_require_comp_name in self.deps_build_info[comp_require_dep_name].components:
                    comp_require_comp_findname = self.deps_build_info[comp_require_dep_name].components[comp_require_comp_name].get_name("cmake_find_package")
                else:
                    raise ConanException("Component '%s' not found in '%s' package requirement"
                                         % (require, comp_require_dep_name))
                comp_requires_findnames.append("{}::{}".format(comp_require_dep_findname, comp_require_comp_findname))
            else:
                comp_require_dep_findname = dep_findname
                comp_require_findname = self.deps_build_info[dep_name].components[require].get_name(
                    "cmake_find_package")
                comp_requires_findnames.append(
                    "{}::{}".format(comp_require_dep_findname, comp_require_findname))
        return ";".join(comp_requires_findnames)

    def _find_for_dep(self, dep_name, cpp_info):
        if not cpp_info.components:
            dep_findname = cpp_info.get_name("cmake_find_package")
            # The common macros
            macros_and_functions = "\n".join([
                CMakeFindPackageCommonMacros.conan_message,
                CMakeFindPackageCommonMacros.apple_frameworks_macro,
                CMakeFindPackageCommonMacros.conan_package_library_targets,
                ])

            # compose the cpp_info with its "debug" or "release" specific config
            dep_cpp_info = cpp_info
            build_type = self.conanfile.settings.get_safe("build_type")
            if build_type:
                dep_cpp_info = extend(dep_cpp_info, build_type.lower())

            # The find_libraries_block, all variables for the package, and creation of targets
            public_deps_names = [self.deps_build_info[dep].get_name("cmake_find_package") for dep in
                                 dep_cpp_info.public_deps]
            deps_names = ";".join(["{n}::{n}".format(n=n) for n in public_deps_names])

            deps = DepsCppCmake(dep_cpp_info)
            find_libraries_block = target_template.format(name=dep_findname, deps=deps,
                                                          build_type_suffix="",
                                                          deps_names=deps_names)

            # The find_transitive_dependencies block
            find_dependencies_block = ""
            if dep_cpp_info.public_deps:
                # Here we are generating FindXXX, so find_modules=True
                f = find_transitive_dependencies(public_deps_names, find_modules=True)
                # proper indentation
                find_dependencies_block = ''.join("        " + line if line.strip() else line
                                                  for line in f.splitlines(True))

            tmp = self.find_template.format(name=dep_findname, version=dep_cpp_info.version,
                                            find_libraries_block=find_libraries_block,
                                            find_dependencies_block=find_dependencies_block,
                                            macros_and_functions=macros_and_functions)
            return tmp
        else:
            pkg_name = dep_name
            pkg_findname = cpp_info.get_name("cmake_find_package")
            return self.find_components_tpl.render(
                pkg_name=pkg_findname,
                pkg_version=cpp_info.version,
                pkg_public_deps=[self.deps_build_info[public_dep].get_name("cmake_find_package") for
                                 public_dep in cpp_info.public_deps],
                components=self._get_components(pkg_name, pkg_findname, cpp_info))

from conans.client.generators.cmake import DepsCppCmake
from conans.client.generators.cmake_find_package_common import target_template
from conans.client.generators.cmake_multi import extend
from conans.model import Generator

find_package_header = """
include(FindPackageHandleStandardArgs)

message(STATUS "Conan: Using autogenerated Find{name}.cmake")
# Global approach
set({name}_FOUND 1)
set({name}_VERSION "{version}")

find_package_handle_standard_args({name} REQUIRED_VARS {name}_VERSION VERSION_VAR {name}_VERSION)
mark_as_advanced({name}_FOUND {name}_VERSION)

"""


class CMakeFindPackageGenerator(Generator):
    template = """
{find_package_header_block}
{find_libraries_block}
if(NOT ${{CMAKE_VERSION}} VERSION_LESS "3.0")
    # Target approach
    if(NOT TARGET {name}::{name})
        {find_dependencies_block}

        add_library({name}::{name} INTERFACE IMPORTED)
        # target_link_libraries({name}::{name} INTERFACE ${{{name}_LIBRARIES_TARGETS}} ${{{name}_SYSTEM_LIBS}} "${{{name}_LINKER_FLAGS_LIST}}")
        set_property(TARGET {name}::{name} PROPERTY INTERFACE_LINK_LIBRARIES ${{{name}_LIBRARIES_TARGETS}} ${{{name}_SYSTEM_LIBS}} "${{{name}_LINKER_FLAGS_LIST}}")
    
        
        # Some more data has to be assigned to the targets (or to the _INTERFACE IMPORTED_ one if there are no actual targets)
        set(_TARGETS_TO_POPULATE "${{{name}_LIBRARIES_ACTUAL_TARGETS}}")
        if (NOT _TARGETS_TO_POPULATE)
            set(_TARGETS_TO_POPULATE "{name}::{name}")
        endif()
        
        if({name}_INCLUDE_DIRS)
            set_target_properties(${{_TARGETS_TO_POPULATE}} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${{{name}_INCLUDE_DIRS}}")
        endif()
        #set_property(TARGET {name}::{name} PROPERTY INTERFACE_LINK_LIBRARIES ${{{name}_LIBRARIES_TARGETS}} ${{{name}_SYSTEM_LIBS}} "${{{name}_LINKER_FLAGS_LIST}}")
        set_target_properties(${{_TARGETS_TO_POPULATE}} PROPERTIES 
            INTERFACE_COMPILE_DEFINITIONS "${{{name}_COMPILE_DEFINITIONS}}"
            INTERFACE_COMPILE_OPTIONS "${{{name}_COMPILE_OPTIONS_LIST}}")
           
    endif()
endif()
"""

    @property
    def filename(self):
        pass

    @property
    def content(self):
        ret = {}
        for _, cpp_info in self.deps_build_info.dependencies:
            depname = cpp_info.get_name("cmake_find_package")
            ret["Find%s.cmake" % depname] = self._find_for_dep(depname, cpp_info)
        return ret

    def _find_for_dep(self, name, cpp_info):
        dep_cpp_info = cpp_info
        build_type = self.conanfile.settings.get_safe("build_type")
        if build_type:
            dep_cpp_info = extend(dep_cpp_info, build_type.lower())

        deps = DepsCppCmake(dep_cpp_info)
        lines = []
        if dep_cpp_info.public_deps:
            # Here we are generating FindXXX, so find_modules=True
            public_deps_names = [self.deps_build_info[dep].get_name("cmake_find_package") for dep in dep_cpp_info.public_deps]
            lines = find_dependency_lines(name, public_deps_names, find_modules=True)
        find_package_header_block = find_package_header.format(name=name, version=dep_cpp_info.version)
        find_libraries_block = target_template.format(name=name, deps=deps, build_type_suffix="")
        tmp = self.template.format(name=name, deps=deps,
                                   version=dep_cpp_info.version,
                                   find_dependencies_block="\n    ".join(lines),
                                   find_libraries_block=find_libraries_block,
                                   find_package_header_block=find_package_header_block)
        return tmp


def find_dependency_lines(name, public_deps_names, find_modules):
    lines = ["", "# Library dependencies", "include(CMakeFindDependencyMacro)"]
    for dep_name in public_deps_names:
        if find_modules:
            lines.append("")
            lines.append("find_dependency(%s REQUIRED)" % dep_name)
            lines.append("foreach(_actual_target ${%s_LIBRARIES_ACTUAL_TARGETS})" % name)
            lines.append("    target_link_libraries(${_actual_target} INTERFACE ${%s_LIBRARIES_TARGETS})" % dep_name)
            lines.append('    message("${_actual_target} ---> ${%s_LIBRARIES_TARGETS}")' % dep_name)
            lines.append("endforeach()")
        else:
            def property_lines(prop):
                lib_t = "%s::%s" % (name, name)
                dep_t = "%s::%s" % (dep_name, dep_name)
                return ["get_target_property(tmp %s %s)" % (dep_t, prop),
                        "if(tmp)",
                        "  set_property(TARGET %s APPEND PROPERTY %s ${tmp})" % (lib_t, prop),
                        'endif()']

            # https://github.com/conan-io/conan/issues/4994
            # https://github.com/conan-io/conan/issues/5040
            lines.append('if(${CMAKE_VERSION} VERSION_LESS "3.9.0")')
            lines.append('  find_package(%s REQUIRED NO_MODULE)' % dep_name)
            lines.append("else()")
            lines.append('  find_dependency(%s REQUIRED NO_MODULE)' % dep_name)
            lines.append("endif()")

            lines.extend(property_lines("INTERFACE_LINK_LIBRARIES"))
            lines.extend(property_lines("INTERFACE_COMPILE_DEFINITIONS"))
            lines.extend(property_lines("INTERFACE_INCLUDE_DIRECTORIES"))
    return ["    {}".format(l) for l in lines]

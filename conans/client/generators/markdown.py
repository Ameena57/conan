import datetime
import os
import textwrap

from jinja2 import DictLoader
from jinja2 import Environment

from conan.tools.cmake.cmakedeps.cmakedeps import CMakeDeps
from conan.tools.cmake.cmakedeps.templates import (
    CMakeDepsFileTemplate,
    get_file_name as cmake_get_file_name)
from conan.tools.gnu.pkgconfigdeps.pc_info_loader import (
    _get_component_name as pkgconfig_get_component_name,
    _get_name_with_namespace as pkgconfig_get_name_with_namespace,
    _get_package_name as pkgconfig_get_package_name
)
from conans.model import Generator


requirement_tpl = textwrap.dedent("""
    {% from 'macros' import render_cpp_info %}

    # {{ requirement }}

    ---
    <br>

    {% if requires or required_by %}
    {% if requires %}
    ## {{ requirement.ref.name }} dependencies
    {% for dep_name, dep in requires %}
    * [{{ dep }}](https://conan.io/center/{{ dep_name }})
    {%- endfor -%}
    {%- endif %}
    {%- if required_by %}
    ## Packages that depend on {{ requirement.ref.name }}
    {%- for dep_name, dep in required_by %}
    *[{{ dep }}](https://conan.io/center/{{ dep_name }})
    {%- endfor -%}
    {%- endif %}
    {% endif %}

    <br>

    ## Using {{ requirement.ref.name }} Conan Package

    <br>

    Conan integrates with different build systems. You can declare which build system you want your project to use setting in the **[generators]** section of the [conanfile.txt](https://docs.conan.io/en/latest/reference/conanfile_txt.html#generators) or using the **generators** attribute in the [conanfile.py](https://docs.conan.io/en/latest/reference/conanfile/attributes.html#generators). Here, there is some basic information you can use to integrate **{{ requirement.ref.name }}** in your own project. For more detailed information, please [check the Conan documentation](https://docs.conan.io/en/latest/getting_started.html).

    {% include 'buildsystem_cmake' %}
    {% include 'buildsystem_vs' %}
    {% include 'buildsystem_autotools' %}
    {% include 'buildsystem_other' %}

    <br>    

    {% if requirement.cpp_info.has_components %}
    ## Declared components

    {%- for component_name, component in requirement.cpp_info.components.items() %}
    {%- if component_name %}
    * Component ``{{ cmake_variables.component_alias[component_name] }}``:

    {{- render_cpp_info(component)|indent(width=2) }}
    {%- endif %}
    {%- endfor %}
    {%- endif %}


    ## Header files

    List of header files exposed by this package. Use them in your ``#include`` directives:

    ```cpp
    {%- for header in headers %}
    #include <{{ header }}>
    {%- endfor %}
    ```

    ---
    ---
    Conan **{{ conan_version }}**. JFrog LTD. [https://conan.io](https://conan.io). Autogenerated {{ now.strftime('%Y-%m-%d %H:%M:%S') }}.
""")

macros = textwrap.dedent("""
    {% macro join_list_sources(items) -%}
    ``{{ "``, ``".join(items) }}``
    {%- endmacro %}

    {% macro render_cpp_info(cpp_info) -%}
    {%- if cpp_info.requires is iterable and cpp_info.requires %}
    * Requires: {{ join_list_sources(cpp_info.requires) }}
    {%- endif %}
    {%- if cpp_info.libs %}
    * Libraries: {{ join_list_sources(cpp_info.libs) }}
    {%- endif %}
    {%- if cpp_info.system_libs %}
    * Systems libs: {{ join_list_sources(cpp_info.system_libs) }}
    {%- endif %}
    {%- if cpp_info.defines %}
    * Preprocessor definitions: {{ join_list_sources(cpp_info.defines) }}
    {%- endif %}
    {%- if cpp_info.cflags %}
    * C_FLAGS: {{ join_list_sources(cpp_info.cflags) }}
    {%- endif %}
    {%- if cpp_info.cxxflags %}
    * CXX_FLAGS: {{ join_list_sources(cpp_info.cxxflags) }}
    {%- endif %}
    {%- endmacro %}
""")

buildsystem_cmake_tpl = textwrap.dedent("""

    ## Using {{ requirement.ref.name }} with CMake

    <br>

    ### [Conan CMake generators](https://docs.conan.io/en/latest/reference/conanfile/tools/cmake.html) 

    <br>

    * [CMakeToolchain](https://docs.conan.io/en/latest/reference/conanfile/tools/cmake/cmaketoolchain.html): generates a CMake toolchain file the you can later invoke with CMake in the command line using `-DCMAKE_TOOLCHAIN_FILE=conantoolchain.cmake`. 

    * [CMakeDeps](https://docs.conan.io/en/latest/reference/conanfile/tools/cmake/cmakedeps.html): generates information about where the **{{ requirement.ref.name }}** library and its dependencies {% if requires %} ({% for dep_name, dep in requires %} [{{ dep_name }}](https://conan.io/center/{{ dep_name }}){% if not loop.last %}, {% endif %} {%- endfor -%}) {%- endif %} are installed together with other information like version, flags, and directory data or configuration. CMake will use this files when you invoke ``find_package()`` in your *CMakeLists.txt*.

    Declare these generators in your **conanfile.txt** along with your **{{ requirement.ref.name }}** dependency like:

    ```ini
    [requires]
    {{ requirement }}

    [generators]
    CMakeToolchain
    CMakeDeps
    ```

    <br>

    To use **{{ requirement.ref.name }}** in a simple CMake project with this structure:

    ```shell
    .
    ├── CMakeLists.txt
    └── src
        └── main{{ project_extension }}
    ```

    <br>

    Your **CMakeLists.txt** could look similar to this, using the global **{{ cmake_variables.global_target_name }}** CMake's target:

    ```cmake
    cmake_minimum_required(VERSION 3.15)
    project({{ requirement.ref.name }}_project {{ project_type }})

    find_package({{ cmake_variables.file_name }})

    add_executable(${PROJECT_NAME} src/main{{ project_extension }})

    # Use the global target
    target_link_libraries(${PROJECT_NAME} {{ cmake_variables.global_target_name }})
    ```

    {% if requirement.cpp_info.has_components %}

    <br>

    This Conan package defines different components. That means you can link only the desired part of the library in your project. For example, linking only with the **agromenauer** component, through the **jande::klander** target that links to **jar, narl, nirl** libraries:

    ```cmake
    # Or link just one of its components
    {% for component_name, component in requirement.cpp_info.components.items() %}
    {%- if loop.index==1 %}
    target_link_libraries(<target_name> {{ cmake_variables.component_alias[component_name] }})
    {%- endif %}
    {%- endfor %}
    ```


    <br>

    ```cmake
    # Or link just one of its components
    {% for component_name, component in requirement.cpp_info.components.items() %}
    {%- if component_name %}
    target_link_libraries(<target_name> {{ cmake_variables.component_alias[component_name] }})
    {%- endif %}
    {%- endfor %}
    ```
    {%- endif %}

    {% set cmake_build_modules = requirement.cpp_info.get_property('cmake_build_modules') %}
    {% if cmake_build_modules %}
    This generator will include some _build modules_:
    {% for bm in cmake_build_modules -%}
    * `{{ relpath(bm, package_folder) | replace("\\\\", "/") }}`
      ```cmake
      {{ bm|read_pkg_file|indent(width=2) }}
      ```
    {%- endfor -%}
    {%- endif %}
""")

buildsystem_vs_tpl = textwrap.dedent("""
    ### Visual Studio

    #### Generator [MSBuildToolchain](https://docs.conan.io/en/latest/reference/conanfile/tools/microsoft.html#msbuildtoolchain)
    `MSBuildToolchain` is the toolchain generator for MSBuild. It translates the current
    package configuration, settings, and options, into a MSBuild properties file that
    you should add to your Visual Sudio solution projects:

    `conantoolchain.props`

    #### Generator [MSBuildDeps](https://docs.conan.io/en/latest/reference/conanfile/tools/microsoft.html#msbuilddeps)
    `MSBuildDeps` is the dependency information generator for Microsoft MSBuild build
    system. It generate a property file with the dependencies of a package ready to be
    used by consumers using MSBuild or Visual Studio.

    Just add the `conandeps.props` file to your solution and projects.
""")

buildsystem_autotools_tpl = textwrap.dedent("""
    ### Autotools

    #### Generator [AutotoolsToolchain](https://docs.conan.io/en/latest/reference/conanfile/tools/gnu/autotoolstoolchain.html)
    `AutotoolsToolchain` is the toolchain generator for Autotools. It will generate
    shell scripts containing environment variable definitions that the autotools build
    system can understand.

    `AutotoolsToolchain` will generate the `conanautotoolstoolchain.sh` or
    `conanautotoolstoolchain.bat` files after a `conan install` command:

    ```shell
    $ conan install conanfile.py # default is Release
    $ source conanautotoolstoolchain.sh
    # or in Windows
    $ conanautotoolstoolchain.bat
    ```

    If your autotools scripts expect to find dependencies using pkg_config, use the
    `PkgConfigDeps` generator. Otherwise, use `AutotoolsDeps`.

    #### Generator AutotoolsDeps
    The AutotoolsDeps is the dependencies generator for Autotools. It will generate
    shell scripts containing environment variable definitions that the autotools
    build system can understand.

    The AutotoolsDeps will generate after a conan install command the
    conanautotoolsdeps.sh or conanautotoolsdeps.bat files:

    ```shell
    $ conan install conanfile.py # default is Release
    $ source conanautotoolsdeps.sh
    # or in Windows
    $ conanautotoolsdeps.bat
    ```


    #### Generator PkgConfigDeps
    This package provides one *pkg-config* file ``{{ pkgconfig_variables.pkg_name }}.pc`` with
    all the information from the library
    {% if requirement.cpp_info.has_components %}
    and, if you want to use the components of the library separately, one `.pc` file per component:
    {% for component_name, component in requirement.cpp_info.components.items() %}
    {%- if component_name %}
    ``{{ pkgconfig_variables.component_alias[component_name] }}.pc``{% if not loop.last %},{% endif %}
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    Use your *pkg-config* tool as usual to consume the information provided by the Conan package.
""")

buildsystem_other_tpl = textwrap.dedent("""
    ### Other build systems
    Conan includes generators for [several more build systems](https://docs.conan.io/en/latest/integrations/build_system.html),
    and you can even write [custom integrations](https://docs.conan.io/en/latest/integrations/custom.html)
    if needed.
""")



class MarkdownGenerator(Generator):
    def _list_headers(self, requirement):
        for include_dir in requirement.cpp_info.includedirs:
            for root, _, files in os.walk(os.path.join(requirement.package_folder, include_dir)):
                for f in files:
                    yield os.path.relpath(os.path.join(root, f), os.path.join(requirement.package_folder, include_dir))

    def _list_requires(self, requirement):
        return [(dep.ref.name, dep) for dep in requirement.dependencies.host.values()]

    def _list_required_by(self, requirement):
        for dep in self.conanfile.dependencies.host.values():
            name = dep.ref.name
            deps = [dep.ref.name for dep in dep.dependencies.host.values()]

            if requirement.ref.name in deps:
                yield name, dep

    @property
    def filename(self):
        pass

    @property
    def content(self):
        dict_loader = DictLoader({
            'macros': macros,
            'package.md': requirement_tpl,
            'buildsystem_cmake': buildsystem_cmake_tpl,
            'buildsystem_vs': buildsystem_vs_tpl,
            'buildsystem_autotools': buildsystem_autotools_tpl,
            'buildsystem_other': buildsystem_other_tpl
        })
        env = Environment(loader=dict_loader)
        template = env.get_template('package.md')

        def read_pkg_file(filename):
            try:
                return open(filename, 'r').read()
            except IOError:
                return '# Error reading file content. Please report.'

        env.filters['read_pkg_file'] = read_pkg_file

        from conans import __version__ as conan_version
        ret = {}
        for requirement in self.conanfile.dependencies.host.values():
            cmake_deps = CMakeDeps(self.conanfile)
            cmake_deps_template = CMakeDepsFileTemplate(cmake_deps,
                                                        requirement,
                                                        self.conanfile,
                                                        find_module_mode=False)

            name = requirement.ref.name

            cmake_component_alias = {
                component_name: cmake_deps_template.get_component_alias(requirement, component_name)
                for component_name, _
                in requirement.cpp_info.components.items()
                if component_name
            }
            project_type = 'C'
            project_extension = '.c'
            if requirement.settings.get_safe('compiler.libcxx') or requirement.settings.get_safe('compiler.cppstd'):
                project_type = 'CXX'
                project_extension = '.cpp'

            cmake_variables = {
                'global_target_name': requirement.cpp_info.get_property('cmake_target_name') or "{0}::{0}".format(name),
                'component_alias': cmake_component_alias,
                'file_name': cmake_get_file_name(requirement)
            }

            pkgconfig_component_alias = {
                component_name: pkgconfig_get_component_name(requirement, component_name) or
                                pkgconfig_get_name_with_namespace(pkgconfig_get_package_name(requirement), component_name)
                for component_name, _
                in requirement.cpp_info.components.items()
                if component_name
            }
            pkgconfig_variables = {
                'pkg_name': pkgconfig_get_package_name(requirement),
                'component_alias': pkgconfig_component_alias
            }

            ret["{}.md".format(name)] = template.render(
                requirement=requirement,
                headers=self._list_headers(requirement),
                requires=list(self._list_requires(requirement)),
                required_by=list(self._list_required_by(requirement)),
                cmake_variables=cmake_variables,
                pkgconfig_variables=pkgconfig_variables,
                package_folder=requirement.package_folder,
                relpath = os.path.relpath,
                conan_version=conan_version,
                now=datetime.datetime.now(),
                project_type=project_type,
                project_extension=project_extension
            )

        return ret
